runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
rated_movies = ratings %>%
group_by(MovieID) %>%
summarize(ratings_per_movie = n(),
ave_ratings = round(mean(Rating), dig=3)) %>%
inner_join(movies, by = 'MovieID')
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
# use colClasses = 'NULL' to skip columns
ratings = read.csv("ratings.dat",
sep = ':',
colClasses = c('integer', 'NULL'),
header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
movies = readLines('movies.dat')
movies = strsplit(movies, split = "::", fixed = TRUE, useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)
# convert accented characters
movies$Title = iconv(movies$Title, "latin1", "UTF-8")
# extract year
movies$Year = as.numeric(unlist(
lapply(movies$Title, function(x) substr(x, nchar(x)-4, nchar(x)-1))))
head(movies)
users = read.csv('users.dat',
sep = ':', header = FALSE)
users = users[, -c(2,4,6,8)] # skip columns
colnames(users) = c('UserID', 'Gender', 'Age', 'Occupation', 'Zip-code')
rated_movies = ratings %>%
group_by(MovieID) %>%
summarize(ratings_per_movie = n(),
ave_ratings = round(mean(Rating), dig=3)) %>%
inner_join(movies, by = 'MovieID')
genres = as.data.frame(rated_movies$Genres, stringsAsFactors=FALSE)
tmp = as.data.frame(tstrsplit(genres[,1], '[|]',
type.convert=TRUE),
stringsAsFactors=FALSE)
genre_list = c("Action", "Adventure", "Animation",
"Children's", "Comedy", "Crime",
"Documentary", "Drama", "Fantasy",
"Film-Noir", "Horror", "Musical",
"Mystery", "Romance", "Sci-Fi",
"Thriller", "War", "Western")
m = length(genre_list)
genre_matrix = matrix(0, nrow(rated_movies), length(genre_list))
for(i in 1:nrow(tmp)){
genre_matrix[i,genre_list %in% tmp[i,]]=1
}
colnames(genre_matrix) = genre_list
remove("tmp", "genres")
tmp = rated_movies[genre_matrix[, "Action"] == 1, ]
tmp = tmp %>%
filter(ratings_per_movie > 500)
tmp = arrange(tmp, -ave_ratings)
View(tmp)
tmp = rated_movies[genre_matrix[, "Action"] == 1, ]
tmp = tmp %>%
filter(ratings_per_movie > 500)
tmp = arrange(tmp, -ave_ratings)
tmp[1:20, ]
tmp[1:20, ]
View(tmp[1:20, ])
runApp()
runApp()
tmp = rated_movies[genre_matrix[, "War"] == 1, ]
tmp = tmp %>%
filter(ratings_per_movie > 500)
tmp = arrange(tmp, -ave_ratings)
View(tmp[1:20, ])
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
head(ratings)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
# use colClasses = 'NULL' to skip columns
ratings = read.csv("ratings.dat",
sep = ':',
colClasses = c('integer', 'NULL'),
header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
head(ratings)
rated_movies = ratings %>%
group_by(MovieID) %>%
summarize(ratings_per_movie = n(),
ave_ratings = round(mean(Rating), dig=3)) %>%
inner_join(movies, by = 'MovieID')
head(rated_movies)
set.seed(100)
train.id = sample(nrow(ratings), floor(nrow(ratings)) * 0.8)
train = ratings[train.id, ]
head(train)
i = paste0('u', train$UserID)
j = paste0('m', train$MovieID)
x = train$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)
set.seed(100)
train.id = sample(nrow(ratings), floor(nrow(ratings)) * 0.8)
train = ratings[train.id, ]
head(train)
test = ratings[-train.id, ]
head(test)
i = paste0('u', train$UserID)
j = paste0('m', train$MovieID)
x = train$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)
set.seed(100)
train.id = sample(nrow(ratings), floor(nrow(ratings)) * 0.8)
train = ratings[train.id, ]
head(train)
test = ratings[-train.id, ]
head(test)
i = paste0('u', train$UserID)
j = paste0('m', train$MovieID)
x = train$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)
rec_UBCF = Recommender(Rmat, method = 'UBCF',
parameter = list(normalize = 'Z-score',
method = 'Cosine',
nn = 25))
#Summary of model parameters
rec_UBCF@model
# predict ratings for the first three users
recom = predict(rec_UBCF,
Rmat[1:3], type = 'ratings')
rec_list = as(recom, 'list')  # each element are ratings of that user
test.pred = test
test.pred$rating = NA
# For all lines in test file, one by one
for (u in 1:nrow(test)){
# Read userid and movieid from columns 2 and 3 of test data
userid = as.numeric(test$UserID[u])
movieid = as.numeric(test$MovieID[u])
rating = rec_list[[userid]][movieid]
# handle missing values; 2.5 might not be the ideal choice
test.pred$rating[u] = ifelse(is.na(rating), 2.5, rating)
}
# predict ratings for the first three users
recom = predict(rec_UBCF,
Rmat[1:3], type = 'ratings')
rec_list = as(recom, 'list')  # each element are ratings of that user
test.pred = test
test.pred$rating = NA
# For all lines in test file, one by one
for (u in 1:nrow(test)){
# Read userid and movieid from columns 2 and 3 of test data
userid = as.numeric(test$UserID[u])
movieid = as.numeric(test$MovieID[u])
rating = rec_list[[userid]][movieid]
# handle missing values; 2.5 might not be the ideal choice
test.pred$rating[u] = ifelse(is.na(rating), 2.5, rating)
}
set.seed(100)
train.id = sample(nrow(ratings), floor(nrow(ratings)) * 0.8)
train = ratings[train.id, ]
head(train)
test = ratings[-train.id, ]
head(test)
i = paste0('u', train$UserID)
j = paste0('m', train$MovieID)
x = train$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)
rec_UBCF = Recommender(Rmat, method = 'UBCF',
parameter = list(normalize = 'Z-score',
method = 'Cosine',
nn = 25))
#Summary of model parameters
rec_UBCF@model
rec_list = as(recom, 'list')  # each element are ratings of that user
test.pred = test
test.pred$rating = NA
# For all lines in test file, one by one
for (u in 1:nrow(test)){
# Read userid and movieid from columns 2 and 3 of test data
userid = as.numeric(test$UserID[u])
movieid = as.numeric(test$MovieID[u])
rating = rec_list[[userid]][movieid]
# handle missing values; 2.5 might not be the ideal choice
test.pred$rating[u] = ifelse(is.na(rating), 2.5, rating)
}
set.seed(100)
train.id = sample(nrow(ratings), floor(nrow(ratings)) * 0.8)
train = ratings[train.id, ]
head(train)
test = ratings[-train.id, ]
head(test)
i = paste0('u', train$UserID)
j = paste0('m', train$MovieID)
x = train$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)
i
j
x
tmp = data.frame(i, j, x, stringsAsFactors = T)
tmp
Rmat
Rmat = new('realRatingMatrix', data = Rmat)
i = paste0('u', train$UserID)
j = paste0('m', train$MovieID)
x = train$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)
Rmat
rec_UBCF = Recommender(Rmat, method = 'UBCF',
parameter = list(normalize = 'Z-score',
method = 'Cosine',
nn = 25))
rec_UBCF
Rmat[1:3]
# predict ratings for the first three users
recom = predict(rec_UBCF,
Rmat[1:3], type = 'ratings')
recom
rec_list = as(recom, 'list')
test.pred = test
test.pred$rating = NA
for (u in 1:nrow(test)){
# Read userid and movieid from columns 2 and 3 of test data
userid = as.numeric(test$UserID[u])
movieid = as.numeric(test$MovieID[u])
rating = rec_list[[userid]][movieid]
# handle missing values; 2.5 might not be the ideal choice
test.pred$rating[u] = ifelse(is.na(rating), 2.5, rating)
}
test
es = evaluationScheme(Rmat, method = "cross", k = 10)
es = evaluationScheme(Rmat, "split", train = 0.8, k = 10)
es = evaluationScheme(Rmat, "split", train = 0.8, k = 10, given = 3)
es = evaluationScheme(Rmat, "split", train = 0.8, k = 10, given = 3)
rec_popular = Recommender(train, method = 'POPULAR')
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
es = evaluationScheme(Rmat, "split", train = 0.8, k = 10, given = 3)
rec_popular = Recommender(train, method = 'POPULAR')
evalScheme = evaluationScheme(Rmat, "split", train = 0.8, k = 10, given = 10)
ubcf = list(name = "UBCF", param = list(normalize = "Z-score"),
method = 'Cosine', weighted = TRUE, nn = 25)
result = evaluate(evalScheme, ubcf, type="ratings")
set.seed(100)
train.id = sample(nrow(ratings), floor(nrow(ratings)) * 0.8)
train = ratings[train.id, ]
head(train)
test = ratings[-train.id, ]
head(test)
i = paste0('u', train$UserID)
j = paste0('m', train$MovieID)
x = train$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)
evalScheme = evaluationScheme(Rmat, "split", train = 0.8, k = 10, given = 10)
ubcf = list(name = "UBCF", param = list(normalize = "Z-score"),
method = 'Cosine', weighted = TRUE, nn = 25)
result = evaluate(evalScheme, ubcf, type="ratings")
es.UBCF = evaluationScheme(Rmat, method="cross-validation", k = 10, train=0.8, given=5)
recommender.UBCF <- Recommender(getData(es.UBCF, "train"), method = "UBCF",
parameter = list(normalize = 'Z-score',
method = 'Cosine',
nn = 25))
p.UBCF <- predict(recommender.UBCF, getData(es.UBCF, "known"), type="ratings")
p.UBCF
View(p.UBCF)
es.UBCF = evaluationScheme(Rmat, method="cross-validation", k = 10, given=5)
es.UBCF
es.UBCF = evaluationScheme(Rmat, method="cross-validation", k = 10, given=5, goodRating = 3)
es.UBCF
recommender.UBCF <- Recommender(getData(es.UBCF, "train"), method = "UBCF",
parameter = list(normalize = 'Z-score',
method = 'Cosine',
nn = 25))
algorithms = list(
"ubcf" = list(
name = "UBCF",
param = list(normalize = "Z-score",
method = 'Cosine',
weighted = TRUE,
nn = 25))
)
schema = evaluationScheme(Rmat, method = "split", train = 0.8, given = 10, k = 10)
results = evaluate(schema, algorithms, type = "ratings")
opts_chunk$set(cache = TRUE, autodep = TRUE)
library(knitr)
library(dplyr)
library(ggplot2)
library(recommenderlab)
library(DT)
library(data.table)
library(reshape2)
opts_chunk$set(cache = TRUE, autodep = TRUE, echo = TRUE)
# use colClasses = 'NULL' to skip columns
ratings = read.csv("ratings.dat",
sep = ':',
colClasses = c('integer', 'NULL'),
header = FALSE)
colnames(ratings) = c('UserID', 'MovieID', 'Rating', 'Timestamp')
head(ratings)
movies = readLines('movies.dat')
movies = strsplit(movies, split = "::", fixed = TRUE, useBytes = TRUE)
movies = matrix(unlist(movies), ncol = 3, byrow = TRUE)
movies = data.frame(movies, stringsAsFactors = FALSE)
colnames(movies) = c('MovieID', 'Title', 'Genres')
movies$MovieID = as.integer(movies$MovieID)
# convert accented characters
movies$Title = iconv(movies$Title, "latin1", "UTF-8")
# extract year
movies$Year = as.numeric(unlist(
lapply(movies$Title, function(x) substr(x, nchar(x)-4, nchar(x)-1))))
head(movies)
users = read.csv('users.dat',
sep = ':', header = FALSE)
users = users[, -c(2,4,6,8)] # skip columns
colnames(users) = c('UserID', 'Gender', 'Age', 'Occupation', 'Zip-code')
rated_movies = ratings %>%
group_by(MovieID) %>%
summarize(ratings_per_movie = n(),
ave_ratings = round(mean(Rating), dig=3)) %>%
inner_join(movies, by = 'MovieID')
head(rated_movies)
genres = as.data.frame(rated_movies$Genres, stringsAsFactors=FALSE)
tmp = as.data.frame(tstrsplit(genres[,1], '[|]',
type.convert=TRUE),
stringsAsFactors=FALSE)
genre_list = c("Action", "Adventure", "Animation",
"Children's", "Comedy", "Crime",
"Documentary", "Drama", "Fantasy",
"Film-Noir", "Horror", "Musical",
"Mystery", "Romance", "Sci-Fi",
"Thriller", "War", "Western")
m = length(genre_list)
genre_matrix = matrix(0, nrow(rated_movies), length(genre_list))
for(i in 1:nrow(tmp)){
genre_matrix[i,genre_list %in% tmp[i,]]=1
}
colnames(genre_matrix) = genre_list
remove("tmp", "genres")
tmp = rated_movies[genre_matrix[, "War"] == 1, ]
tmp = tmp %>%
filter(ratings_per_movie > 500)
tmp = arrange(tmp, -ave_ratings)
i = paste0('u', ratings$UserID)
j = paste0('m', ratings$MovieID)
x = ratings$Rating
tmp = data.frame(i, j, x, stringsAsFactors = T)
Rmat = sparseMatrix(as.integer(tmp$i), as.integer(tmp$j), x = tmp$x)
rownames(Rmat) = levels(tmp$i)
colnames(Rmat) = levels(tmp$j)
Rmat = new('realRatingMatrix', data = Rmat)
algorithms = list(
"ubcf" = list(
name = "UBCF",
param = list(normalize = "Z-score",
method = 'Cosine',
weighted = TRUE,
nn = 25)),
"ibcf" = list(
name = "IBCF",
param = list(normalize = "Z-score",
method = 'Cosine',
weighted = TRUE,
k = 25))
)
schema = evaluationScheme(Rmat, method = "split", train = 0.8, given = 10, k = 10)
results = evaluate(schema, algorithms, type = "ratings")
schema = evaluationScheme(Rmat, method = "split", train = 0.8, given = 10, k = 10)
ubcf = list(
name = "UBCF",
param = list(normalize = "Z-score",
method = 'Cosine',
weighted = TRUE,
nn = 25))
results = evaluate(schema, ubcf, type = "ratings")
ubcf = list(
name = "UBCF",
param = list(normalize = "Z-score",
method = 'Cosine',
weighted = TRUE,
nn = 25))
results = evaluate(schema, list("ubcf" = ubcf), type = "ratings")
ubcf = list(
name = "UBCF",
param = list(normalize = "Z-score",
method = 'Cosine',
weighted = TRUE,
nn = 25))
ubcf_results = evaluate(schema, list("ubcf" = ubcf), type = "ratings")
ibcf = list(
name = "IBCF",
param = list(normalize = "Z-score",
method = 'Cosine',
k = 25))
ibcf_results = evaluate(schema, list("ibcf" = ibcf), type = "ratings")
?evaluate
getResults(ibcf_results)
ibcf_result
ibcf_results
names(ibcf_results)
ibcf_results$ibcf
names(ibcf_results$ibcf)
getResults(ibcf_results$ibcf)
ibcf_rmse = rep(0, 10)
for (i in 1:10){
ibcf_rmse[i] = getResults(ibcf_results$ibcf)[[i]]$RMSE
}
ibcf_rmse = rep(0, 10)
for (i in 1:10){
ibcf_rmse[i] = getResults(ibcf_results$ibcf)[[i]][1]
}
ibcf_rmse
getResults(ibcf_results$ibcf)[[1]]
head(getResults(ubcf_results$ubcf))
getResults(ubcf_results$ubcf)[[1]]
ubcf_rmse = rep(0, 10)
for (i in 1:10){
ubcf_rmse[i] = getResults(ubcf_results$ubcf)[[i]][1]
}
ubcf_rmse
rec_IBCF = Recommender(Rmat, method = 'IBCF',
parameter = list(normalize = 'Z-score',
method = 'Cosine',
nn = 25))
rec_IBCF = Recommender(Rmat, method = 'IBCF',
parameter = list(normalize = 'Z-score',
method = 'Cosine',
k = 25))
rec_IBCF = Recommender(Rmat, method = 'IBCF',
parameter = list(normalize = 'Z-score',
method = 'Cosine',
k = 25))
